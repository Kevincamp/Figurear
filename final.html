<!DOCTYPE html>
<html>
	<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="js/three.js"></script>
		<script type="text/javascript" src="js/poly2tri.js"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css" />
        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300" />
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.0/jquery.min.js"></script>
        <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>
        <title>Figurear</title>
    </head>
    <body onload="webGLStart()">
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="js/materialize.min.js"></script>
        <titulo> Figurear </titulo>
        <div id="wrapper"
                    onmousedown="mouseDownEvent(event.clientX, event.clientY)"
                    onmousemove="mouseMoveEvent(event.clientX, event.clientY)"
                    onmouseup="mouseUpEvent(event.clientX, event.clientY)"
                    oncontextmenu="return false;">
            <div class="water-drop"></div>
            <div class="button button-floating"></div>
            <div class="button-floating-shadow"></div>
            <div class="button button-sub" data-color="purple">
            </div>
            <div class="button button-sub" data-color="green">
            </div>
            <div class="button button-sub" data-color="pink">
            </div>
            <div class="button button-sub" data-color="indigo">
            </div>
        </div>
        <footer>
            By <a href="" target="_blank">Adrian Aguilar </a> //
            <a href="" target="_blank">Kevin Campuzano </a> // 
            <a href="" target="_blank">Marlon Loayza </a>
        </footer>
        <script type="text/javascript">

            /* Declaracion de variables */
            var cantidadTachuela = 0;
            var puntoInicial = null;
            var puntoFinal = null;
            var puntos_figura = [];
            var puntos_remuestreados =[];
            var listaLineasFigura=[];
            var listaTriangulosFigura=[];
            var listaTriangulos =[];
            var puntos_malla=[];
            var list_lineas=[];
            var lista_tachuelas = [];
            var pressed = false;
            var container;
            var camera, scene, projector, renderer;
            var particleMaterial;
            var isRotating=false;
            var nuevo=false;
            var mover=false;
            var tachuela = false;
            var first_pos ;
            var last_pos;



            /* -- Funciones adicionales creadas -- ********************************************/

            function get3dPointZAxis(event) {

                var vector = new THREE.Vector3(
                    ( event.clientX / window.innerWidth ) * 2 - 1,
                    - ( event.clientY / window.innerHeight ) * 2 + 1,
                    0.5 );
                vector.unproject(camera );
                var dir = vector.sub( camera.position ).normalize();
                var dist = - camera.position.z / dir.z;
                var pos = camera.position.clone().add( dir.multiplyScalar( dist ) );    
                return pos;
            }

            function agregarTachuela(x, y){

                i=0;
                var p=new THREE.Vector3(x,y,0);
                var distancia = 10000000000;
                var d=0;
                var punto
                while(i < puntos_malla.length){
                    pos=puntos_malla[i];
                    d =pos.distanceTo(p)  ;//distance(pos,p) ;
                    if(d < distancia){
                        distancia= d;
                        punto= pos;
                    }
                    i=i+1;
                }
                var sphere = new THREE.Mesh(
                new THREE.SphereGeometry(7, 10, 10),
                new THREE.MeshPhongMaterial({color: 0x000000}));
                
                sphere.position.set(punto.x, punto.y, 0);
                lista_tachuelas.push(sphere);
                scene.add(sphere);
                render();
            }

            function roundline(){

                var tam = puntos_figura.length-1;
                var start=[puntos_figura[tam].x , puntos_figura[tam].y];
                var end =  [puntos_figura[0].x , puntos_figura[0].y];
                var dx = parseInt(end[0])- parseInt(start[0]);
                var dy = parseInt(end[1])-parseInt(start[1]);
                var distanc = Math.max(Math.abs(dx), Math.abs(dy));
                for(var i=0 ; i<distanc ; i=i+3){
                    var x = parseInt( start[0]+parseFloat(i)/distanc*dx);
                    var y = parseInt( start[1]+parseFloat(i)/distanc*dy);
                    puntos_figura.push(new THREE.Vector3(x, y, 0));
                    last_pos= new THREE.Vector3(x, y, 0);
                }
            }

            function resample(n){

                var pathle= pathlength(puntos_figura);
                var I =  pathle/ parseFloat(n-1);
                var D = 0;
                var i = 1
                while( i< puntos_figura.length){
                    if (i==1){  
                        puntos_remuestreados.push(new THREE.Vector3(parseInt(puntos_figura[0].x),parseInt(puntos_figura[0].y),0));
                    }
                    p1 = puntos_figura[i];
                    p2 = puntos_figura[i-1];
                    d = p2.distanceTo( p1 );
                    if( (D + d) >= I && d !=0){
                        qx = p2.x + ((I-D) / d) * (p1.x - p2.x);
                        qy = p2.y + ((I-D) / d) * (p1.y - p2.y);
                        puntos_remuestreados.push(new THREE.Vector3(parseInt(qx), parseInt(qy),0));
                        D = 0
                    }else{
                        D = D + d;
                     }
                    i+=1;
                }
            }

            function encontrarCentroide(){

                var i =0 ;
                var x =0;
                var y =0;
                var tam = puntos_remuestreados.length;
                while( i< tam){
                    x = x + puntos_remuestreados[i].x;
                    y = y + puntos_remuestreados[i].y;
                    i=i+1;
                }
                posx = parseInt(x/tam);
                posy = parseInt(y/tam);
                malla(posx,posy);
            }

            function encontrarTriangulos(){

                var Material=new THREE.PointsMaterial({color:0XFF0000});
                var material = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true });
                var i=0;
                while(i<listaTriangulos.length){
                    l=listaTriangulos[i];
                    p1=l[0];
                    p2=l[1];
                    p3=l[2];
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);
                    geometry.vertices.push(p3);
                    geometry.faces.push(new THREE.Face3(0, 1, 2));
                    var triangulo = new THREE.Mesh(geometry, material);
                    listaTriangulosFigura.push(triangulo);
                    i=i+1;
                }
            }

            function repaint(){

                var i=0;
                while(i<listaTriangulosFigura.length){
                    var l=listaTriangulosFigura[i];
                    scene.add(l);
                    render();
                    i=i+1;
                }
            }

            function dibujarLinea(i1, i2) {

                var v1 = puntos_figura[i1];
                var v2 = puntos_figura[i2];
                var Material=new THREE.PointsMaterial({color:0XFF0000});
                var geometry = new THREE.Geometry();
                geometry.vertices.push(v1);
                geometry.vertices.push(v2);
                var line = new THREE.Line(geometry,Material);
                scene.add(line);
                render();
            }

            function pathlength(points){

                var d=0;
                for(var i=0 ; i< points.length-1; i++){
                    var p = points[i];
                    var p2 = points[i+1];
                    d = d + p.distanceTo( p2 );
                }
                return d;
            }

            function malla(posx,posy){

              var Puntos = [];
              Puntos.push(new THREE.Vector3(-10,-17,0)); 
              Puntos.push(new THREE.Vector3(-20,0,0));
              Puntos.push(new THREE.Vector3(-10,17,0));
              Puntos.push(new THREE.Vector3(10,17,0));
              Puntos.push(new THREE.Vector3(20,0,0));
              Puntos.push(new THREE.Vector3(10,-17,0));
              var nuevoPuntos = [];
              for(var i=0 ; i< Puntos.length ; i++){
                nuevoPuntos.push(new THREE.Vector3(posx+Puntos[i].x,posy+Puntos[i].y,0));
              }
              while(nuevoPuntos.length != 0){
                var pos= nuevoPuntos.pop();
                if (!estaEnLista(puntos_malla,pos.x,pos.y) &&  insidePolygon(puntos_remuestreados, pos)){
                  var indice=0;
                  puntos_malla.push(pos);
                  while(indice < Puntos.length-1){
                    var valor=Puntos[indice];
                    var valor2=Puntos[indice+1];
                    p=new THREE.Vector3(pos.x+valor.x,pos.y+valor.y,0);
                    p2=new THREE.Vector3(pos.x+valor2.x,pos.y+valor2.y,0);
                    if( insidePolygon(puntos_remuestreados, p)){
                        nuevoPuntos.push(p);
                        if( insidePolygon(puntos_remuestreados, p2)){
                            var v1 = pos ;
                            var v2 = p;
                            var v3 = p2;
                            t=[v1 ,v2 ,v3];
                            t1=[v1 ,v2];
                            t2=[v2 ,v3];
                            t3=[v1 ,v3];
                            if (!existeTriangulo(t)){
                                listaTriangulos.push(t);
                            }
                        }
                    }
                    indice=indice+1
                  }
                }
              }
            }

            function estaEnLista(Lista , posx, posy){

                i=0;
                while(i < Lista.length){
                    pos=Lista[i];
                    if (pos.x == posx && pos.y==posy){
                        return true;
                    }
                    i=i+1;
                } 
                return false;
            }

            function insidePolygon( pointList , p ) {

               var counter = 0;
               var i;
               var xinters;
               var p1  ;
               var p2;
               var n = pointList.length;
               p1 = pointList[0];
               for (i = 1; i <= n; i++) {
                  p2 = pointList[i % n];
                  if (p.y > Math.min(p1.y, p2.y)) {
                     if (p.y <= Math.max(p1.y, p2.y)) {
                        if (p.x <= Math.max(p1.x, p2.x)) {
                           if (p1.y != p2.y) {
                              xinters = (p.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
                              if (p1.x == p2.x || p.x <= xinters)
                                 counter++;
                           }
                        }
                     }
                  }
                  p1 = p2;
               }
               if (counter % 2 == 0) {
                  return(false);
               }
               else {
                  return(true);
               }
            }

            function existeTriangulo(t){

                var v1=t[0];
                var v2=t[1];
                var v3=t[2];
                var x1 = v1.x;
                var y1 = v1.y;
                var x2 = v2.x;
                var y2 = v2.y;
                var x3 = v3.x;
                var y3 = v3.y;
                i=0;
                while(i<listaTriangulos.length){
                    t=listaTriangulos[i];

                    p1=t[0];
                    p2=t[1];
                    p3=t[2];
                    if (   (x1 == p1.x && y1 == p1.y && x2 == p2.x && y2 == p2.y && x3 == p3.x && y3 == p3.y) 
                        || (x2 == p1.x && y2 == p1.y && x1 == p2.x && y1 == p2.y && x3 == p3.x && y3 == p3.y)
                        || (x3 == p1.x && y3 == p1.y && x1 == p2.x && y1 == p2.y && x2 == p3.x && y2 == p3.y)
                        || (x2 == p1.x && y2 == p1.y && x3 == p2.x && y3 == p2.y && x1 == p3.x && y1 == p3.y)
                        || (x3 == p1.x && y3 == p1.y && x2 == p2.x && y2 == p2.y && x1 == p3.x && y1 == p3.y)
                        || (x1 == p1.x && y1 == p1.y && x3 == p2.x && y3 == p2.y && x2 == p3.x && y2 == p3.y)){
                        return true;
                    }

                    i=i+1;
                }
                return false;
            }

            /* -- Fin de Funciones adicionales creadas -- *******************************************
               -- Eventos de Botones -- ******************************************* */
            function doNew(){
                console.info("entro a doNew");
                puntos_figura.splice(0,puntos_figura.length);
                puntos_remuestreados.splice(0,puntos_remuestreados.length);
                listaLineasFigura.splice(0,listaLineasFigura.length);
                puntos_malla.splice(0,puntos_malla.length);
                list_lineas.splice(0,list_lineas.length);
                lista_tachuelas.splice(0,lista_tachuelas.length);
                listaTriangulosFigura.splice(0,listaTriangulosFigura.length);
                listaTriangulos.splice(0,listaTriangulos.length);
                cantidadTachuela=0;
                nuevo = true;
                mover=false;
                tachuela = false;
                pressed=false;
                initState();
            }

            function putTach(){
                console.info("Entro a poner tachuelas");
                tachuela = true;
                mover = false;
                nuevo = false;
                pressed=false;
            }

            function moveTach(){
                console.info("Entro a Translacion.");
                tachuela = false;
                mover = true;
                nuevo = false;
            }

            /* -- Fin de Eventos de Botones -- ******************************************* 
               -- Listener de Botones Flotantes -- *************************************** */

            $(document).ready(function() {
                $(".button-floating").click(function() {
                    var $wrapper = $("#wrapper");

                    if (!$wrapper.hasClass("button-floating-clicked"))
                    {
                        $wrapper.attr("class", "center");
                        $wrapper.toggleClass("button-floating-clicked-out");
                    }

                    $wrapper.toggleClass("button-floating-clicked");

                    $(".button-sub").click(function() {
                        var color = $(this).data("color");

                        if(color == "purple"){
                            console.info("Dibuja");
                            doNew();
                        } else if(color == "green"){
                            console.info("Tachuela");
                            putTach();
                        } else if(color == "pink"){
                            console.info("Mueve");
                            moveTach();
                        }else if (color == "indigo"){
                            console.info("Guarda");
                        }else{
                            console.info("No hace nada");
                        }
                        $wrapper.attr("class", "button-floating-clicked");
                        $wrapper.addClass("button-sub-" + color + "-clicked");
                    });
                });
            });

            /* -- Fin de Listener de Botones Flotantes -- ******************************************* 
               -- Eventos del Mouse -- *************************************** */

            function mouseDownEvent(x, y) {
                p = get3dPointZAxis(event);
                var pos=new THREE.Vector3(p.x,p.y+70,0);
                                   

                if (nuevo){
                    puntos_figura.length = 1;
                    puntos_figura[0] = new THREE.Vector3(pos.x, pos.y, 0);
                    first_pos = puntos_figura[0];
                    nuevo=false;
                    pressed=true;
                    
                }
                if(tachuela && cantidadTachuela<1){
                    cantidadTachuela ++;
                    agregarTachuela(pos.x, pos.y);
                    tachuela = false
                    pressed = false
                    

                }
                if(mover) {
                    var tachue=lista_tachuelas[0];
                    var x= tachue.position.x;
                    var y= tachue.position.y;
                    if (pos.x<= (x+10) && pos.x>=(x-10) && pos.y<= (y+10) && pos.y>= (y-10)){
                        pressed=true;
                    }
                }   
            }

            function mouseMoveEvent(x,y) {
                if (pressed)
                {
                    var p = get3dPointZAxis(event);
                    var pos=new THREE.Vector3(p.x,p.y+70,0);
                    var diferenciax, diferenciay;
                    if (!nuevo && mover){
                        moverFigura(pos);
                    }else{
                        puntos_figura.push(new THREE.Vector3(pos.x, pos.y, 0));
                        dibujarLinea(puntos_figura.length - 2, puntos_figura.length - 1);
                    }
                }
            }

            function mouseUpEvent(x,y) {

                punto = get3dPointZAxis(event);
                if (pressed)
                {
                    pressed=false;
                    if(!nuevo && !mover){
                        last_pos= new THREE.Vector3(punto.x, punto.y+70, 0);
                        puntos_figura.push(last_pos);
                        roundline();
                        resample(60);
                        initState();
                        render();
                        encontrarCentroide();
                        encontrarTriangulos();
                        repaint();
                    }
                }
            }

            
            

            /* -- Fin de Eventos del Mouse -- ******************************************* 
               -- Inicializacion de Web -- ********************************************** */

            function webGLStart() {
                console.info("Entro a WebGLStart");
                init();
            }
            function init(){
                console.info("Entro a init");
                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0xE6E6E6, 1);
                renderer.setSize(document.getElementById("wrapper").width, document.getElementById("wrapper").canvasHeight);
                document.getElementById("wrapper").appendChild(renderer.domElement);
                initState();
            }

            function initState(){
                console.info("Entro a initState");
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.set( 500, 500, 500 );
                scene = new THREE.Scene();
            }

            function render() {
                renderer.render( scene, camera );
            }
            /* -- Fin de Inicializacion de Web -- ************************************** */
            
        </script>
    </body>
</html>